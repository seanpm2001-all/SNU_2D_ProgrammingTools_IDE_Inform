// The documentation tab

#include "stdafx.h"
#include "TabDoc.h"
#include "Inform.h"
#include "Panel.h"
#include "Messages.h"
#include "TextFormat.h"

#include <algorithm>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(TabDoc, TabBase)

BEGIN_MESSAGE_MAP(TabDoc, TabBase)
  ON_WM_SIZE()
  ON_COMMAND(ID_DOC_CONTENTS, OnContents)
  ON_MESSAGE(WM_USERNAVIGATE, OnUserNavigate)
END_MESSAGE_MAP()

CArray<TabDoc::DocText> TabDoc::m_docTexts;

TabDoc::TabDoc() : m_html(NULL), m_initialised(false)
{
}

const char* TabDoc::GetName(void)
{
  return "Documentation";
}

void TabDoc::CreateTab(CWnd* parent)
{
  // Create the pane window
  Create(parent);

  // Create the command button
  m_contents.Create("Contents",WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),this,ID_DOC_CONTENTS);
  m_contents.SetFont(&m_font);

  // Create the HTML control window
  m_html = (ReportHtml*)(RUNTIME_CLASS(ReportHtml)->CreateObject());
  if (!m_html->Create(NULL,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),this,1))
  {
    TRACE("Failed to create HTML control\n");
  }
}

void TabDoc::MoveTab(CRect& rect)
{
  MoveWindow(rect,TRUE);
}

void TabDoc::MakeActive(TabState& state)
{
  if (!m_initialised)
  {
    // Show the index page
    m_html->Navigate(theApp.GetAppDir()+"\\Documentation\\index.html",true);
    m_initialised = true;
  }

  // Make the window visible
  ShowWindow(SW_SHOW);
  m_html->SetFocusOnContent();

  // Use and update the given tab state
  if (state.tab == Panel::Tab_Doc)
    Show(state.url);
  GetTabState(state);
}

BOOL TabDoc::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
  if (m_html->OnCmdMsg(nID,nCode,pExtra,pHandlerInfo))
    return TRUE;
  return CWnd::OnCmdMsg(nID,nCode,pExtra,pHandlerInfo);
}

void TabDoc::CompileProject(CompileStage stage, int code)
{
  if (stage == RanNaturalInform)
  {
    if (code == 0)
    {
      // Reload the current page, in case it is generated by compilation
      m_html->Refresh();
    }
  }
}

void TabDoc::Show(const char* url)
{
  m_html->Navigate(url,true);
  m_initialised = true;
}

void TabDoc::SetFocusFlag(bool set)
{
  m_html->SetFocusFlag(set);
}

static bool SortBySource(SearchWindow::Result& result1, SearchWindow::Result& result2)
{
  return result1.sourceSort < result2.sourceSort;
}

void TabDoc::Search(LPCWSTR text, std::vector<SearchWindow::Result>& results)
{
  CWaitCursor wc;

  CStringW textLow(text);
  textLow.MakeLower();

  if (m_docTexts.IsEmpty())
  {
    bool example = false;
    CFileFind findDoc;

    for (int i = 0; i < 2; i++)
    {
      CString findPath;
      switch (i)
      {
      case 0:
        example = false;
        findPath.Format("%s\\Documentation\\sections\\doc*.html",theApp.GetAppDir());
        break;
      case 1:
        example = true;
        findPath.Format("%s\\Documentation\\sections\\ex*.html",theApp.GetAppDir());
        break;
      }

      BOOL found = findDoc.FindFile(findPath);
      while (found)
      {
        // Get the filename of a documentation file
        found = findDoc.FindNextFile();

        // Extract the title and body text
        DocText docText;
        docText.example = example;
        if (DecodeHTML(findDoc.GetFilePath(),docText))
        {
          docText.file = findDoc.GetFilePath();
          m_docTexts.Add(docText);
        }
        theApp.RunMessagePump();
      }
    }
  }

  for (int i = 0; i < m_docTexts.GetSize(); i++)
  {
    DocText& docText = m_docTexts[i];

    // Make everything lower case
    CStringW bodyLow(docText.body);
    bodyLow.MakeLower();

    // Look for a match
    int found1 = bodyLow.Find(textLow);
    if (found1 != -1)
    {
      int found2 = found1+textLow.GetLength();

      // Create a larger range to extract the context
      int context1 = found1-8;
      if (context1 < 0)
        context1 = 0;
      int context2 = found2+32;
      if (context2 > docText.body.GetLength()-1)
        context2 = docText.body.GetLength()-1;

      // Get the surrounding text as context
      CStringW context = docText.body.Mid(context1,context2-context1);
      context.Replace(L'\n',L' ');
      context.Replace(L'\r',L' ');
      context.Replace(L'\t',L' ');

      SearchWindow::Result result;
      result.context = context;
      result.inContext.cpMin = found1-context1;
      result.inContext.cpMax = found2-context1;
      CString location;
      location.Format("%s: %s",docText.section,docText.title);
      result.sourceLocation = location;
      result.sourceSort = docText.sort;
      result.sourceFile = docText.file;

      // For examples, add a reference to the example section
      if (docText.example)
      {
        int sep = docText.file.ReverseFind('\\');
        if (sep != -1)
        {
          CString name = docText.file.Mid(sep+1);
          name.MakeLower();

          int number = 0;
          if (sscanf(name,"ex%d.html",&number) == 1)
          {
            CString section;
            section.Format("#e%d",number);
            result.sourceFile += section;
          }
        }
      }

      results.push_back(result);
    }
    theApp.RunMessagePump();
  }

  // Sort the search results by the documentation page they are found in
  std::sort(results.begin(),results.end(),SortBySource);
}

void TabDoc::Highlight(const SearchWindow::Result& result)
{
  std::wstring search = result.context.substr(
    result.inContext.cpMin,result.inContext.cpMax-result.inContext.cpMin);
  m_html->Navigate(result.sourceFile.c_str(),false,search.c_str());
  m_initialised = true;
  Panel::GetPanel(this)->SetActiveTab(Panel::Tab_Doc);
}

CString TabDoc::Description(void)
{
  return "documentation";
}

CRect TabDoc::WindowRect(void)
{
  CRect r;
  m_html->GetWindowRect(r);
  return r;
}

void TabDoc::OnSize(UINT nType, int cx, int cy)
{
  TabBase::OnSize(nType,cx,cy);

  if (m_html->GetSafeHwnd() == 0)
    return;

  CRect client;
  GetClientRect(client);

  // Call the base class to resize and get parameters
  CSize fontSize;
  int heading, h;
  SizeTab(client,fontSize,heading,h);

  int cw = theApp.MeasureText(&m_contents).cx+(fontSize.cx*3);
  m_contents.MoveWindow(client.Width()-cw-(fontSize.cx/3),h,cw,heading-(2*h),TRUE);

  m_html->MoveWindow(client,TRUE);
}

void TabDoc::OnContents()
{
  Show(theApp.GetAppDir()+"\\Documentation\\index.html");
  Panel::GetPanel(this)->SetActiveTab(Panel::Tab_Doc);
}

LRESULT TabDoc::OnUserNavigate(WPARAM, LPARAM)
{
  if (IsWindowVisible())
  {
    TabState state;
    GetTabState(state);
    Panel::GetPanel(this)->AddToTabHistory(state);
  }
  return 0;
}

void TabDoc::GetTabState(TabState& state)
{
  state.tab = Panel::Tab_Doc;
  state.url = m_html->GetURL();
}

CString TabDoc::GetToolTip(UINT_PTR id)
{
  switch (id)
  {
  case ID_DOC_CONTENTS:
    return "Show the contents page of the documentation";
  }
  return TabBase::GetToolTip(id);
}

struct Tag
{
  const wchar_t* name;
  int len;
  bool remove;
  bool cr;
};

static struct Tag tags[] =
{
  L"a",          1,false,false,
  L"B>",         2,false,false,
  L"b>",         2,false,false,
  L"blockquote",10,false,false,
  L"br",         2,false,true,
  L"font",       4,false,false,
  L"h",          1,false,false,
  L"i>",         2,false,false,
  L"img",        3,false,false,
  L"p>",         2,false,true,
  L"p ",         2,false,true,
  L"script",     6,true, false,
  L"table",      5,false,false,
  L"TABLE",      5,false,false,
  L"td",         2,false,false,
  L"TD",         2,false,false,
  L"tr",         2,false,false,
  L"TR",         2,false,false,
  L"div",        3,false,false,
  L"pre",        3,false,false,
};

struct Literal
{
  const wchar_t* name;
  int len;
  char replace;
};

static struct Literal literals[] =
{
  L"quot;",5,'\"',
  L"nbsp;",5,' ',
  L"lt;",3,'<',
  L"gt;",3,'>',
};

bool TabDoc::DecodeHTML(const char* filename, DocText& docText)
{
  // Open the file
  CFile htmlFile;
  if (htmlFile.Open(filename,CFile::modeRead) == 0)
    return false;

  // Read it into memory
  CString htmlText;
  int len = (int)htmlFile.GetLength();
  htmlFile.Read(htmlText.GetBuffer(len),len);
  htmlText.ReleaseBuffer(len);

  // Convert from UTF-8 to Unicode
  CStringW html = TextFormat::UTF8ToUnicode(htmlText);

  // Get the body text
  int body1 = html.Find(L"<body");
  if (body1 == -1)
    return false;
  body1 = html.Find(L">",body1);
  if (body1 == -1)
    return false;
  int body2 = html.Find(L"</body>");
  if (body2 <= body1)
    return false;
  CStringW bodyHtml = html.Mid(body1+1,body2-body1-1);

  // Reserve space for the main text
  len = bodyHtml.GetLength();
  docText.body.Preallocate(bodyHtml.GetLength());

  // Scan the text, removing markup
  bool example = false;
  bool white = false;
  const wchar_t* p1 = bodyHtml;
  const wchar_t* p2 = p1+len;
  while (p1 < p2)
  {
    // Look for a markup element
    if ((*p1 == L'<') && (iswalpha(*(p1+1)) || (*(p1+1) == L'/')))
    {
      // Check for a closing markup element
      bool closing = false;
      if (*(p1+1) == L'/')
      {
        closing = true;
        p1++;
      }

      // Scan for a known markup element
      bool found = false;
      int i = 0;
      while (!found && (i < sizeof tags / sizeof tags[0]))
      {
        if (wcsncmp(p1+1,tags[i].name,tags[i].len) == 0)
          found = true;
        if (!found)
          i++;
      }
      ASSERT(found);

      // Remove the markup
      if (found && tags[i].remove)
      {
        ASSERT(!closing);

        // Remove everything until the closing element
        CStringW search;
        search.Format(L"</%s>",tags[i].name);
        p1 = wcsstr(p1,search);
        if (p1 != NULL)
          p1 += search.GetLength()-1;
        else
          p1 = p2;
      }
      else
      {
        // Remove just the element
        while ((p1 < p2) && (*p1 != L'>'))
          p1++;
      }
      ASSERT(*p1 == L'>');

      // Add a carriage return for appropriate markup
      if (found && !closing && tags[i].cr)
        docText.AddToBody(L'\n',example);
      white = false;
    }
    else if ((*p1 == L'<') && (*(p1+1) == L'!'))
    {
      // Extract metadata from comments
      wchar_t meta[256];
      if (swscanf(p1,L"<!-- SEARCH TITLE \"%[^\"]",meta) == 1)
        docText.title = meta;
      else if (swscanf(p1,L"<!-- SEARCH SECTION \"%[^\"]",meta) == 1)
        docText.section = meta;
      else if (swscanf(p1,L"<!-- SEARCH SORT \"%[^\"]",meta) == 1)
        docText.sort = meta;
      else if (wcsncmp(p1,L"<!-- EXAMPLE START -->",22) == 0)
        example = true;
      else if (wcsncmp(p1,L"<!-- EXAMPLE END -->",20) == 0)
        example = false;

      p1 = wcsstr(p1,L"-->");
      if (p1 != NULL)
        p1 += 2;
      else
        p1 = p2;
    }
    else if (*p1 == L'&')
    {
      // Scan for a known literal
      bool found = false;
      int i = 0;
      while (!found && (i < sizeof literals / sizeof literals[0]))
      {
        if (wcsncmp(p1+1,literals[i].name,literals[i].len) == 0)
          found = true;
        if (!found)
          i++;
      }

      // Replace the literal
      if (found)
      {
        docText.AddToBody(literals[i].replace,example);
        p1 += literals[i].len;
      }
      else
        docText.AddToBody(*p1,example);
      white = false;
    }
    else if (iswspace(*p1))
    {
      if (!white)
        docText.AddToBody(L' ',example);
      white = true;
    }
    else
    {
      docText.AddToBody(*p1,example);
      white = false;
    }
    p1++;
  }

/*
  CString bodyA(docText.body);
  AfxMessageBox(bodyA);
*/
  return true;
}

TabDoc::DocText::DocText() : example(false)
{
}

void TabDoc::DocText::AddToBody(WCHAR ch, bool inExample)
{
  if (!example || (example && inExample))
    body += ch;
}
